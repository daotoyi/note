(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{591:function(s,t,e){"use strict";e.r(t);var a=e(20),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"_1条消息-linux后台运行、挂起、恢复进程相关命令-koberonaldo24的博客-csdn博客"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1条消息-linux后台运行、挂起、恢复进程相关命令-koberonaldo24的博客-csdn博客"}},[s._v("#")]),s._v(" (1条消息) linux后台运行、挂起、恢复进程相关命令_koberonaldo24的博客-CSDN博客")]),s._v(" "),e("blockquote",[e("h2",{attrs:{id:"excerpt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#excerpt"}},[s._v("#")]),s._v(" Excerpt")]),s._v(" "),e("p",[s._v("记录一些日常会用到的linux真心好用的操作。后台运行临时后台运行如果只是临时有一个命令需要长时间运行，需要最简便的保证它在后台稳定运行：nohup/setsid/&我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于...")])]),s._v(" "),e("hr"),s._v(" "),e("h2",{attrs:{id:"临时后台运行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时后台运行"}},[s._v("#")]),s._v(" 临时后台运行")]),s._v(" "),e("p",[s._v("如果只是临时有一个命令需要长时间运行，需要最简便的保证它在后台稳定运行：")]),s._v(" "),e("h3",{attrs:{id:"nohup-setsid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nohup-setsid"}},[s._v("#")]),s._v(" nohup/setsid/&")]),s._v(" "),e("p",[s._v("我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。")]),s._v(" "),e("h5",{attrs:{id:"_1-nohup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-nohup"}},[s._v("#")]),s._v(" 1.nohup")]),s._v(" "),e("p",[s._v('nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&“来将命令同时放入后台运行，也可用”>filename 2>&1"来更改缺省的重定向文件名。'),e("br"),s._v("\nnohup示例")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[root@pvcent107 ~]\n[1] 3059\nnohup: appending output to `nohup.out'\n[root@pvcent107 ~]\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h4",{attrs:{id:"_2-setid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-setid"}},[s._v("#")]),s._v(" 2.setid")]),s._v(" "),e("p",[s._v("nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。"),e("br"),s._v("\nsetsid 示例")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[root@pvcent107 ~]\n[root@pvcent107 ~]\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h4",{attrs:{id:"_3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3"}},[s._v("#")]),s._v(" 3.&")]),s._v(" "),e("p",[s._v("这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。")]),s._v(" "),e("p",[s._v('当我们将"&"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。'),e("br"),s._v("\nsubshell示例")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[root@pvcent107 ~]\n[root@pvcent107 ~]\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h2",{attrs:{id:"screen"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#screen"}},[s._v("#")]),s._v(" screen")]),s._v(" "),e("p",[s._v("如果有大量命令需要在稳定的后台里运行，此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。")]),s._v(" "),e("p",[s._v("使用 screen 很方便，有以下几个常用选项：")]),s._v(" "),e("ul",[e("li",[s._v("用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。")]),s._v(" "),e("li",[s._v("用screen -list 来列出所有会话。")]),s._v(" "),e("li",[s._v("用screen -r session name来重新连接指定会话。")]),s._v(" "),e("li",[s._v("用快捷键CTRL-a d 来暂时断开当前会话。")])]),s._v(" "),e("p",[s._v("screen 示例")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[root@pvcent107 ~]\n[root@pvcent107 ~]\nThere is a screen on:\n        12842.Urumchi   (Detached)\n1 Socket i\n[root@pvcent107 ~]\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。")]),s._v(" "),e("h3",{attrs:{id:"ctrl-z"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ctrl-z"}},[s._v("#")]),s._v(" ctrl + z")]),s._v(" "),e("p",[s._v("可以将一个正在前台执行的命令放到后台，并且处于暂停状态。")]),s._v(" "),e("h3",{attrs:{id:"jobs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jobs"}},[s._v("#")]),s._v(" jobs")]),s._v(" "),e("p",[s._v("查看当前有多少在后台运行的命令")]),s._v(" "),e("p",[s._v("jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。")]),s._v(" "),e("h3",{attrs:{id:"fg"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fg"}},[s._v("#")]),s._v(" fg")]),s._v(" "),e("p",[s._v("将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出。")]),s._v(" "),e("h3",{attrs:{id:"bg"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bg"}},[s._v("#")]),s._v(" bg")]),s._v(" "),e("p",[s._v("将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出。")]),s._v(" "),e("h3",{attrs:{id:"kill"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kill"}},[s._v("#")]),s._v(" kill")]),s._v(" "),e("p",[s._v("法子1：通过jobs命令查看job号（假设为num），然后执行kill %num"),e("br"),s._v("\n法子2：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid")]),s._v(" "),e("p",[s._v("前台进程的终止：Ctrl+c")])])}),[],!1,null,null,null);t.default=n.exports}}]);