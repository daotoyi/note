(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{680:function(e,a,_){"use strict";_.r(a);var s=_(20),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,_=e._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("[toc]")]),e._v(" "),_("p",[e._v("当工程大的时候，就需要分出很多包来管理，各个模块间不可避免地出现要引入其它模块。如果没有仔细去了解绝对导入和相对导入的规则，我们在引入模块的时候就很可能遇见各种问题。最常见的就是 "),_("code",[e._v("ModuleNotFoundError: No module named 'moduleY'")]),e._v("、"),_("code",[e._v("ValueError: attempted relative import beyond top-level package")]),e._v("、"),_("code",[e._v("ModuleNotFoundError: No module named '__main__.moduleY'; '__main__' is not a package")]),e._v("等这些异常，本文试着从导入语句的角度带大家了解 Python 的导入机制的冰山一角。")]),e._v(" "),_("p",[e._v("Python 2 和 Python 3 的导入机制会有些差异，本文以 Python 3.8 为基准。")]),e._v(" "),_("p",[e._v("假如我们目前遇到的包的布局如下：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n    moduleA.py\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br"),_("span",{staticClass:"line-number"},[e._v("6")]),_("br"),_("span",{staticClass:"line-number"},[e._v("7")]),_("br"),_("span",{staticClass:"line-number"},[e._v("8")]),_("br"),_("span",{staticClass:"line-number"},[e._v("9")]),_("br"),_("span",{staticClass:"line-number"},[e._v("10")]),_("br")])]),_("h2",{attrs:{id:"_1-基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本原理"}},[e._v("#")]),e._v(" 1 基本原理")]),e._v(" "),_("p",[e._v("在 Python 里面，一个 "),_("code",[e._v(".py")]),e._v(" 文件可以称为模块，包含了 "),_("code",[e._v("__init__.py")]),e._v(" 文件的称为包。")]),e._v(" "),_("p",[e._v("当一个模块被执行时，Python 会从 "),_("code",[e._v("sys.path")]),e._v(" 给出的路径去找在模块中引入的包或其它模块，如果找不到，程序就会报错。")]),e._v(" "),_("h2",{attrs:{id:"_2-绝对导入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-绝对导入"}},[e._v("#")]),e._v(" "),_("strong",[e._v("2 绝对导入")])]),e._v(" "),_("p",[e._v("绝对导入是默认的导入方式，因为它更常见，并且它有相对导入的所有功能。")]),e._v(" "),_("h3",{attrs:{id:"_2-1-用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-用法"}},[e._v("#")]),e._v(" 2.1 用法")]),e._v(" "),_("p",[e._v("绝对导入可以使用 "),_("code",[e._v("import <>")]),e._v(" 或 "),_("code",[e._v("from <> import <>")]),e._v(" 这两种语法，比如在 "),_("code",[e._v("moduleA")]),e._v(" 模块里面，使用下面的绝对导入语句是有效的。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("import package.subpackage1.moduleX as moduleX\nfrom package.subpackage1 import moduleY\nfrom subpackage2 import moduleZ\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("不过，需要注意的是，在当前模块中引入同级别的模块或者同级别的包下的模块的时候，最好把导入路径写完整。比如，在 "),_("code",[e._v("moduleX")]),e._v(" 模块中引入了同一级别的 "),_("code",[e._v("moduleY")]),e._v("：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleX.py\n\nimport moduleY\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[_("code",[e._v("moduleA")]),e._v(" 的代码：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleA.py\n\nimport package.subpackage1.moduleX\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("执行 "),_("code",[e._v("python moduleA.py")]),e._v(" 会提示 "),_("code",[e._v("ModuleNotFoundError: No module named 'moduleY'")]),e._v("。")]),e._v(" "),_("p",[e._v("因为执行模块 "),_("code",[e._v("moduleA")]),e._v(" 的路径是"),_("code",[e._v("D:/top/package")]),e._v("（"),_("code",[e._v("D:/top")]),e._v(" 是示例程序在我本机的目录），导入语句"),_("code",[e._v("import moduleY")]),e._v(" 将会被解析并定位到 "),_("code",[e._v("D:/top/package/moduleY.py")]),e._v("，很明显这个路径不存在。")]),e._v(" "),_("p",[e._v("把模块 "),_("code",[e._v("moduleX")]),e._v(" 中的 "),_("code",[e._v("import moduleY")]),e._v(" 改成 "),_("code",[e._v("import package.subpackage1.moduleY")]),e._v(" 或 "),_("code",[e._v("from package.subpackage1 import moduleX")]),e._v(" 就可以正常运行。")]),e._v(" "),_("h3",{attrs:{id:"_2-2-不足"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-不足"}},[e._v("#")]),e._v(" 2.2 不足")]),e._v(" "),_("ol",[_("li",[e._v("导入同一个包下的模块需要写完整的导入路径，如果层级很深，这个路径会显得很长。")]),e._v(" "),_("li",[e._v("假如要改变层级较高的包名，比如顶级包，那么所有导入路径都要改。")])]),e._v(" "),_("h2",{attrs:{id:"_3-相对导入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-相对导入"}},[e._v("#")]),e._v(" 3 "),_("strong",[e._v("相对导入")])]),e._v(" "),_("p",[e._v("相对导入解决了绝对导入的一些问题：")]),e._v(" "),_("ol",[_("li",[e._v("同一个包下的模块可以很方便的相互引用，使用像 "),_("code",[e._v("from . import xxx")]),e._v(" 的语句就行。")]),e._v(" "),_("li",[e._v("顶层包的报名改了，包下的模块的相对导入的语句基本不用改。")])]),e._v(" "),_("h3",{attrs:{id:"_3-1-用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-用法"}},[e._v("#")]),e._v(" 3.1 用法")]),e._v(" "),_("p",[e._v("相对导入只能使用 "),_("code",[e._v("from <> import <>")]),e._v(" 这种语法，并且使用 "),_("code",[e._v(".")]),e._v(" 作为前导点。")]),e._v(" "),_("p",[e._v("比如，在 "),_("code",[e._v("subpackage1/moduleX.py")]),e._v(" 或者 "),_("code",[e._v("subpackage1/__init__.py")]),e._v(" 模块里面，我们可以使用相对导入的方式导入其它模块。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("from .moduleY import spam\nfrom .moduleY import spam as ham\nfrom . import moduleY\nfrom ..subpackage1 import moduleY\nfrom ..subpackage2.moduleZ import eggs\nfrom ..moduleA import foo\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br"),_("span",{staticClass:"line-number"},[e._v("6")]),_("br")])]),_("h3",{attrs:{id:"_3-2-实现机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-实现机制"}},[e._v("#")]),e._v(" 3.2 实现机制")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.python.org/dev/peps/pep-0328/#id12",target:"_blank",rel:"noopener noreferrer"}},[e._v("PEP 328"),_("OutboundLink")],1),e._v(" 中有一段介绍了使用相对导入时查找导入模块机制：")]),e._v(" "),_("blockquote",[_("p",[e._v("Relative imports use a module's "),_("code",[e._v("__name__")]),e._v("attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to "),_("code",[e._v("'__main__'")]),e._v(") then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.")])]),e._v(" "),_("p",[e._v("简单来说，就是在相对导入里面，一个模块的位置是由该模块的 "),_("code",[e._v("__name__")]),e._v(" 属性来确定，如果该属性值不包含任何包的信息，则把当前模块视为顶层模块。比如，在 "),_("code",[e._v("moduleA")]),e._v("、"),_("code",[e._v("moduleZ")]),e._v(" 中分别加入一条可以输出"),_("code",[e._v("__name__")]),e._v(" 、"),_("code",[e._v("__package__")]),e._v(" 的值的语句。")]),e._v(" "),_("p",[_("code",[e._v("moduleA.py")]),e._v(" 的代码：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleA.py\nprint('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(__file__,__name__,str(__package__)))\n\nfrom subpackage2 import moduleZ\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br")])]),_("p",[_("code",[e._v("moduleZ.py")]),e._v(" 的代码：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleZ.py\nprint('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(__file__,__name__,str(__package__)))\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br")])]),_("p",[e._v("执行命令 "),_("code",[e._v("python moduleA.py")]),e._v(" 将会输出：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("__file__=D:/top/package/moduleA.py | __name__=__main__             | __package__=None                \n__file__=D:\\top\\package\\subpackage2\\moduleZ.py | __name__=subpackage2.moduleZ  | __package__=subpackage2         \n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br")])]),_("p",[e._v("我们发现 "),_("code",[e._v("moduleA.py")]),e._v(" 的 "),_("code",[e._v("__name__")]),e._v(" 是 "),_("code",[e._v("'__main__'")]),e._v("，即 "),_("code",[e._v("moduleA.py")]),e._v(" 作为顶层模块。"),_("code",[e._v("moduleZ.py")]),e._v(" 的 "),_("code",[e._v("__name__")]),e._v(" 是 "),_("code",[e._v("subpackage2.moduleZ")]),e._v("，所以模块 "),_("code",[e._v("moduleZ.py")]),e._v(" 的顶级包是 "),_("code",[e._v("subpackage2")]),e._v(" 而不是 "),_("code",[e._v("package")]),e._v(" 。")]),e._v(" "),_("h3",{attrs:{id:"_3-3-限制条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-限制条件"}},[e._v("#")]),e._v(" 3.3 限制条件")]),e._v(" "),_("h3",{attrs:{id:"相对导入只适用于顶级包内的模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相对导入只适用于顶级包内的模块"}},[e._v("#")]),e._v(" 相对导入只适用于顶级包内的模块")]),e._v(" "),_("p",[e._v("在模块里可通过属性 "),_("code",[e._v("__package__")]),e._v(" 获取自身的包信息，即该模块所在包的结构，诸如 "),_("code",[e._v("XXX")]),e._v("、"),_("code",[e._v("XXX.YYY.ZZZ")]),e._v(" 等形式，第一个节点就是顶层包，如果 "),_("code",[e._v("__package__")]),e._v(" 为 "),_("code",[e._v("None")]),e._v(" 表示该模块是顶层模块。")]),e._v(" "),_("p",[e._v("在模块 "),_("code",[e._v("moduleY")]),e._v(" 中引入 "),_("code",[e._v("subpackage2")]),e._v(" 包下的 "),_("code",[e._v("moduleZ")]),e._v(" 模块：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleY.py\n\nfrom ..subpackage2 import moduleZ\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("执行文件 "),_("code",[e._v("moduleA.py")]),e._v(" 的代码：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleA.py\n\nimport subpackage1.moduleY\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("执行 "),_("code",[e._v("python moduleA.py")]),e._v(" 会引发 "),_("code",[e._v("ValueError: attempted relative import beyond top-level package")]),e._v(" 异常。")]),e._v(" "),_("p",[e._v("因为模块 "),_("code",[e._v("moduleY")]),e._v(" 所在的顶级包是 "),_("code",[e._v("subpackage1")]),e._v("，而 "),_("code",[e._v("subpackage1")]),e._v(" 包下不存在子包 "),_("code",[e._v("subpackage2")]),e._v("。")]),e._v(" "),_("h3",{attrs:{id:"使用了相对导入的模块文件不能作为顶层执行文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用了相对导入的模块文件不能作为顶层执行文件"}},[e._v("#")]),e._v(" "),_("strong",[e._v("使用了相对导入的模块文件不能作为顶层执行文件")])]),e._v(" "),_("p",[e._v("对于下面"),_("code",[e._v("moduleX.py")]),e._v(" 的代码，执行 "),_("code",[e._v("python moduleX.py")]),e._v(" 将会引发 "),_("code",[e._v("ModuleNotFoundError: No module named '__main__.moduleY'; '__main__' is not a package")]),e._v(" 异常。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("# moduleX.py\n\nfrom .moduleY import *\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);